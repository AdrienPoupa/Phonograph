diff --git a/app/src/main/java/com/kabouzeid/gramophone/helper/SearchQueryHelper.java b/app/src/main/java/com/kabouzeid/gramophone/helper/SearchQueryHelper.java
index eae42a80..54f95623 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/helper/SearchQueryHelper.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/helper/SearchQueryHelper.java
@@ -71,7 +71,6 @@ public class SearchQueryHelper {
             return songs;
         }
 
-
         songs = SongLoader.getSongs(SongLoader.makeSongCursor(context, ARTIST_SELECTION, new String[]{query.toLowerCase().trim()}));
         if (!songs.isEmpty()) {
             return songs;
diff --git a/app/src/main/java/com/kabouzeid/gramophone/loader/SongLoader.java b/app/src/main/java/com/kabouzeid/gramophone/loader/SongLoader.java
index 7d84c992..231b494d 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/loader/SongLoader.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/loader/SongLoader.java
@@ -2,6 +2,7 @@ package com.kabouzeid.gramophone.loader;
 
 import android.content.Context;
 import android.database.Cursor;
+import android.database.MergeCursor;
 import android.provider.BaseColumns;
 import android.provider.MediaStore;
 import android.provider.MediaStore.Audio.AudioColumns;
@@ -13,6 +14,7 @@ import com.kabouzeid.gramophone.provider.BlacklistStore;
 import com.kabouzeid.gramophone.util.PreferenceUtil;
 
 import java.util.ArrayList;
+import java.util.List;
 
 /**
  * @author Karim Abou Zeid (kabouzeid)
@@ -32,6 +34,7 @@ public class SongLoader {
             AudioColumns.ARTIST_ID,// 9
             AudioColumns.ARTIST,// 10
     };
+    private static final int BATCH_SIZE = 900; // used in makeSongCursor* functions. SQLite limit on the number of ?argument is 999, we leave some to the other call sites.
 
     @NonNull
     public static ArrayList<Song> getAllSongs(@NonNull Context context) {
@@ -96,6 +99,43 @@ public class SongLoader {
         return new Song(id, title, trackNumber, year, duration, data, dateModified, albumId, albumName, artistId, artistName);
     }
 
+    @Nullable
+    public static Cursor makeSongCursorFromPaths(@NonNull final Context context, @NonNull ArrayList<String> paths) {
+        // Exclude blacklist
+        paths.removeAll(BlacklistStore.getInstance(context).getPaths());
+
+        int remaining = paths.size();
+        int processed = 0;
+
+        ArrayList<Cursor> cursors = new ArrayList<>();
+        while (remaining > 0) {
+            final int currentBatch = Math.min(BATCH_SIZE, remaining);
+
+            StringBuilder selection = new StringBuilder();
+            selection.append(BASE_SELECTION + " AND " + MediaStore.Audio.AudioColumns.DATA + " IN (?");
+            for (int i = 1; i < currentBatch; i++) {
+                selection.append(",?");
+            }
+            selection.append(")");
+
+            try {
+                Cursor cursor = context.getContentResolver().query(
+                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    BASE_PROJECTION, 
+                    selection.toString(), 
+                    paths.subList(processed, processed + currentBatch).toArray(new String[currentBatch]),
+                    PreferenceUtil.getInstance(context).getSongSortOrder()
+                );
+                if (cursor != null) {cursors.add(cursor);};
+            } catch (SecurityException ignored) {
+            }
+
+            remaining -= currentBatch;
+            processed += currentBatch;
+        }
+        return new MergeCursor(cursors.toArray(new Cursor[cursors.size()]));
+    }
+
     @Nullable
     public static Cursor makeSongCursor(@NonNull final Context context, @Nullable final String selection, final String[] selectionValues) {
         return makeSongCursor(context, selection, selectionValues, PreferenceUtil.getInstance(context).getSongSortOrder());
@@ -110,35 +150,59 @@ public class SongLoader {
         }
 
         // Blacklist
-        ArrayList<String> paths = BlacklistStore.getInstance(context).getPaths();
-        if (!paths.isEmpty()) {
-            selection = generateBlacklistSelection(selection, paths.size());
-            selectionValues = addBlacklistSelectionValues(selectionValues, paths);
-        }
-
-        try {
-            return context.getContentResolver().query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
-                    BASE_PROJECTION, selection, selectionValues, sortOrder);
-        } catch (SecurityException e) {
-            return null;
+        final ArrayList<String> paths = BlacklistStore.getInstance(context).getPaths();
+        int remaining = paths.size();
+        int processed = 0;
+
+        ArrayList<Cursor> cursors = new ArrayList<>();
+        while (remaining > 0) {
+            final int currentBatch = Math.min(BATCH_SIZE, remaining);
+
+            // Enrich the base selection with the current batch parameters
+            String batchSelection = generateBlacklistSelection(selection, currentBatch);
+            ArrayList<String> batchSelectionValues = addBlacklistSelectionValues(selectionValues, paths.subList(processed, processed + currentBatch));
+
+            try {
+                Cursor cursor = context.getContentResolver().query(
+                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                    BASE_PROJECTION,
+                    batchSelection,
+                    batchSelectionValues.toArray(new String[batchSelectionValues.size()]),
+                    sortOrder
+                );
+                if (cursor != null) {cursors.add(cursor);}
+            } catch (SecurityException ignored) {
+            }
+
+            remaining -= currentBatch;
+            processed += currentBatch;
         }
+        return new MergeCursor(cursors.toArray(new Cursor[cursors.size()]));
     }
 
     private static String generateBlacklistSelection(String selection, int pathCount) {
-        String newSelection = selection != null && !selection.trim().equals("") ? selection + " AND " : "";
+        String newSelection = (selection != null && !selection.trim().equals("")) ? selection + " AND " : "";
         newSelection += AudioColumns.DATA + " NOT LIKE ?";
-        for (int i = 0; i < pathCount - 1; i++) {
+        for (int i = 1; i < pathCount; i++) {
             newSelection += " AND " + AudioColumns.DATA + " NOT LIKE ?";
         }
         return newSelection;
     }
 
-    private static String[] addBlacklistSelectionValues(String[] selectionValues, ArrayList<String> paths) {
-        if (selectionValues == null) selectionValues = new String[0];
-        String[] newSelectionValues = new String[selectionValues.length + paths.size()];
-        System.arraycopy(selectionValues, 0, newSelectionValues, 0, selectionValues.length);
-        for (int i = selectionValues.length; i < newSelectionValues.length; i++) {
-            newSelectionValues[i] = paths.get(i - selectionValues.length) + "%";
+    private static ArrayList<String> addBlacklistSelectionValues(String[] selectionValues, @NonNull final List<String> paths) {
+        ArrayList<String> newSelectionValues = null;
+        if (selectionValues == null) {
+            newSelectionValues = new ArrayList<String>(paths.size());
+        }
+        else {
+            newSelectionValues = new ArrayList<String>(selectionValues.length + paths.size());
+            for (int i=0; i < selectionValues.length; ++i) {
+                newSelectionValues.add(selectionValues[i]);
+            }
+        }
+
+        for (int i = 0; i < paths.size(); i++) {
+            newSelectionValues.add(paths.get(i) + "%");
         }
         return newSelectionValues;
     }
diff --git a/app/src/main/java/com/kabouzeid/gramophone/loader/TopAndRecentlyPlayedTracksLoader.java b/app/src/main/java/com/kabouzeid/gramophone/loader/TopAndRecentlyPlayedTracksLoader.java
index 53c35eb2..522fceba 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/loader/TopAndRecentlyPlayedTracksLoader.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/loader/TopAndRecentlyPlayedTracksLoader.java
@@ -31,7 +31,7 @@ import com.kabouzeid.gramophone.util.PreferenceUtil;
 import java.util.ArrayList;
 
 public class TopAndRecentlyPlayedTracksLoader {
-    public static final int NUMBER_OF_TOP_TRACKS = 100;
+    public static final int NUMBER_OF_TOP_TRACKS = 99;
 
     @NonNull
     public static ArrayList<Song> getRecentlyPlayedTracks(@NonNull Context context) {
diff --git a/app/src/main/java/com/kabouzeid/gramophone/provider/HistoryStore.java b/app/src/main/java/com/kabouzeid/gramophone/provider/HistoryStore.java
index 62346aa4..5634b067 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/provider/HistoryStore.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/provider/HistoryStore.java
@@ -25,8 +25,6 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
 public class HistoryStore extends SQLiteOpenHelper {
-    private static final int MAX_ITEMS_IN_DB = 5000;
-
     public static final String DATABASE_NAME = "history.db";
     private static final int VERSION = 1;
     @Nullable
@@ -80,28 +78,6 @@ public class HistoryStore extends SQLiteOpenHelper {
             values.put(RecentStoreColumns.ID, songId);
             values.put(RecentStoreColumns.TIME_PLAYED, System.currentTimeMillis());
             database.insert(RecentStoreColumns.NAME, null, values);
-
-            // if our db is too large, delete the extra items
-            Cursor oldest = null;
-            try {
-                oldest = database.query(RecentStoreColumns.NAME,
-                        new String[]{RecentStoreColumns.TIME_PLAYED}, null, null, null, null,
-                        RecentStoreColumns.TIME_PLAYED + " ASC");
-
-                if (oldest != null && oldest.getCount() > MAX_ITEMS_IN_DB) {
-                    oldest.moveToPosition(oldest.getCount() - MAX_ITEMS_IN_DB);
-                    long timeOfRecordToKeep = oldest.getLong(0);
-
-                    database.delete(RecentStoreColumns.NAME,
-                            RecentStoreColumns.TIME_PLAYED + " < ?",
-                            new String[]{String.valueOf(timeOfRecordToKeep)});
-
-                }
-            } finally {
-                if (oldest != null) {
-                    oldest.close();
-                }
-            }
         } finally {
             database.setTransactionSuccessful();
             database.endTransaction();
diff --git a/app/src/main/java/com/kabouzeid/gramophone/util/FileUtil.java b/app/src/main/java/com/kabouzeid/gramophone/util/FileUtil.java
index 05f51270..1146394a 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/util/FileUtil.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/util/FileUtil.java
@@ -38,41 +38,22 @@ public final class FileUtil {
 
     @Nullable
     public static SortedCursor makeSongCursor(@NonNull final Context context, @Nullable final List<File> files) {
-        String selection = null;
-        String[] paths = null;
-
+        ArrayList<String> paths = new ArrayList<String>();
         if (files != null) {
             paths = toPathArray(files);
-
-            if (files.size() > 0 && files.size() < 999) { // 999 is the max amount Androids SQL implementation can handle.
-                selection = MediaStore.Audio.AudioColumns.DATA + " IN (" + makePlaceholders(files.size()) + ")";
-            }
         }
 
-        Cursor songCursor = SongLoader.makeSongCursor(context, selection, selection == null ? null : paths);
-
-        return songCursor == null ? null : new SortedCursor(songCursor, paths, MediaStore.Audio.AudioColumns.DATA);
-    }
-
-    private static String makePlaceholders(int len) {
-        StringBuilder sb = new StringBuilder(len * 2 - 1);
-        sb.append("?");
-        for (int i = 1; i < len; i++) {
-            sb.append(",?");
-        }
-        return sb.toString();
+        Cursor songCursor = SongLoader.makeSongCursorFromPaths(context, paths);
+        return songCursor == null ? null : new SortedCursor(songCursor, paths.toArray(new String[paths.size()]), MediaStore.Audio.AudioColumns.DATA);
     }
 
     @Nullable
-    private static String[] toPathArray(@Nullable List<File> files) {
-        if (files != null) {
-            String[] paths = new String[files.size()];
-            for (int i = 0; i < files.size(); i++) {
-                paths[i] = safeGetCanonicalPath(files.get(i));
-            }
-            return paths;
+    private static ArrayList<String> toPathArray(@Nullable List<File> files) {
+        ArrayList<String> paths = new ArrayList<String>(files.size());
+        for (int i = 0; i < files.size(); i++) {
+            paths.set(i, safeGetCanonicalPath(files.get(i)));
         }
-        return null;
+        return paths;
     }
 
     @NonNull
diff --git a/app/src/main/java/com/kabouzeid/gramophone/util/MusicUtil.java b/app/src/main/java/com/kabouzeid/gramophone/util/MusicUtil.java
index 24f569cb..030d09c2 100644
--- a/app/src/main/java/com/kabouzeid/gramophone/util/MusicUtil.java
+++ b/app/src/main/java/com/kabouzeid/gramophone/util/MusicUtil.java
@@ -258,59 +258,71 @@ public class MusicUtil {
         final String[] projection = new String[]{
                 BaseColumns._ID, MediaStore.MediaColumns.DATA
         };
-        final StringBuilder selection = new StringBuilder();
-        selection.append(BaseColumns._ID + " IN (");
-        for (int i = 0; i < songs.size(); i++) {
-            selection.append(songs.get(i).id);
-            if (i < songs.size() - 1) {
+
+        // Split the query into multiple batches, and merge the resulting cursors
+        int songIndex = 0;
+        final int batchSize = 1000000 / 10; // 10^6 being the SQLite limite on the query lenth in bytes, 10 being the max number of digits in an int, used to store the track ID
+        final int songCount = songs.size();
+
+        while (songIndex < songCount)
+        {
+            final StringBuilder selection = new StringBuilder();
+            selection.append(BaseColumns._ID + " IN (");
+
+            for (int i = 0; (i < batchSize - 1) && (songIndex < songCount - 1); i++, songIndex++) {
+                selection.append(songs.get(songIndex).id);
                 selection.append(",");
             }
-        }
-        selection.append(")");
+            // The last element of a batch
+            selection.append(songs.get(songIndex).id);
+            songIndex++;
+            selection.append(")");
 
-        try {
-            final Cursor cursor = context.getContentResolver().query(
-                    MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection.toString(),
-                    null, null);
-            if (cursor != null) {
-                // Step 1: Remove selected tracks from the current playlist, as well
-                // as from the album art cache
-                cursor.moveToFirst();
-                while (!cursor.isAfterLast()) {
-                    final int id = cursor.getInt(0);
-                    final Song song = SongLoader.getSong(context, id);
-                    MusicPlayerRemote.removeFromQueue(song);
-                    cursor.moveToNext();
-                }
+            try {
+                final Cursor cursor = context.getContentResolver().query(
+                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, projection, selection.toString(),
+                        null, null);
+                if (cursor != null) {
+                    // Step 1: Remove selected tracks from the current playlist, as well
+                    // as from the album art cache
+                    cursor.moveToFirst();
+                    while (!cursor.isAfterLast()) {
+                        final int id = cursor.getInt(0);
+                        final Song song = SongLoader.getSong(context, id);
+                        MusicPlayerRemote.removeFromQueue(song);
+                        cursor.moveToNext();
+                    }
+
+                    // Step 2: Remove selected tracks from the database
+                    context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
+                            selection.toString(), null);
 
-                // Step 2: Remove selected tracks from the database
-                context.getContentResolver().delete(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
-                        selection.toString(), null);
-
-                // Step 3: Remove files from card
-                cursor.moveToFirst();
-                while (!cursor.isAfterLast()) {
-                    final String name = cursor.getString(1);
-                    try { // File.delete can throw a security exception
-                        final File f = new File(name);
-                        if (!f.delete()) {
-                            // I'm not sure if we'd ever get here (deletion would
-                            // have to fail, but no exception thrown)
-                            Log.e("MusicUtils", "Failed to delete file " + name);
+                    // Step 3: Remove files from card
+                    cursor.moveToFirst();
+                    while (!cursor.isAfterLast()) {
+                        final String name = cursor.getString(1);
+                        try { // File.delete can throw a security exception
+                            final File f = new File(name);
+                            if (!f.delete()) {
+                                // I'm not sure if we'd ever get here (deletion would
+                                // have to fail, but no exception thrown)
+                                Log.e("MusicUtils", "Failed to delete file " + name);
+                            }
+                            cursor.moveToNext();
+                        } catch (@NonNull final SecurityException ex) {
+                            cursor.moveToNext();
+                        } catch (NullPointerException e) {
+                            Log.e("MusicUtils", "Failed to find file " + name);
                         }
-                        cursor.moveToNext();
-                    } catch (@NonNull final SecurityException ex) {
-                        cursor.moveToNext();
-                    } catch (NullPointerException e) {
-                        Log.e("MusicUtils", "Failed to find file " + name);
                     }
+                    cursor.close();
                 }
-                cursor.close();
+            } catch (SecurityException ignored) {
             }
-            context.getContentResolver().notifyChange(Uri.parse("content://media"), null);
-            Toast.makeText(context, context.getString(R.string.deleted_x_songs, songs.size()), Toast.LENGTH_SHORT).show();
-        } catch (SecurityException ignored) {
         }
+
+        context.getContentResolver().notifyChange(Uri.parse("content://media"), null);
+        Toast.makeText(context, context.getString(R.string.deleted_x_songs, songCount), Toast.LENGTH_SHORT).show();
     }
 
     public static boolean isFavoritePlaylist(@NonNull final Context context, @NonNull final Playlist playlist) {
